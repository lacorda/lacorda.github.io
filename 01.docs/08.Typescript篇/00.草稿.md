---
description: 草稿
slug: /98659a5
tags: 
  - 草稿
---
## 草稿

### 类型推断

在创建变量并将其赋值给特定值时， TypeScript 将该值的类型作为变量类型  => 不需要添加额外的字符来显式地指定类型

### 接口interface


使用 `interface` 关键字声明显式数据类型

在变量声明后使用像 `: TypeName`

#### 将接口声明与类一起使用:

```ts
interface User {
  name: string;
  id: number;
}
 
class UserAccount {
  name: string;
  id: number;
 
  constructor(name: string, id: number) {
    this.name = name;
    this.id = id;
  }
}
 
const user: User = new UserAccount("Murphy", 1);
```

#### 对参数进行注释，并将值返回给函数

```ts
interface User {
  name: string;
  id: number;
}
// ---分割线---
function getAdminUser(): User {
  //...
}
 
function deleteUser(user: User) {
  // ...
}
```

### 自带的类型

#### js的基本类型
`boolean`
`number`
`string`
`object`
`Array`
`undefined`
`null`
`bigint`
`symbol`

#### ts的扩展类型
`any` （允许任何类型）
`unknown` （确保使用此类型的人声明类型是什么）
`never` （这种类型不可能发生）
`void` （返回 `undefined` 或`没有返回值的函数`）


### 接口interface和类型type的区别

[https://juejin.cn/post/6844903749501059085#comment](https://juejin.cn/post/6844903749501059085#comment)

用`interface`描述**数据结构**，用`type`描述**类型关系**

1、type 还可以定义字符串字面量类型，type x = 'a' | 'b' | 'c' 那么使用该类型只能从这三个值中取，不在的就会报错。
2、另外使用type比较多的地方就是联合类型，如函数返回类型是type x = string | object | void，就不用一次次的写，复用性就高了。

### enum是什么

[https://jkchao.github.io/typescript-book-chinese/typings/enums.html](https://jkchao.github.io/typescript-book-chinese/typings/enums.html)

### 组合类型

> 通过组合简单类型来创建复杂类型, 联合 和 泛型

#### 联合

> 联合类型的一个流行用法是描述 `string` 或者 `number` 的字面量的合法值。
> eg: 将 `boolean` 类型描述为 `true` 或 `false`
> 函数参数里也可以使用 `function getLength(obj: string | string[]) { return obj.length; }`


```ts
type MyBool = true | false;

type WindowStates = "open" | "closed" | "minimized";
type LockStates = "locked" | "unlocked";
type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;

function getLength(obj: string | string[]) {
  return obj.length;
}

function wrapInArray(obj: string | string[]) {
  if (typeof obj === "string") {
    return [obj];
            
(parameter) obj: string
  }
  return obj;
}
```

#### 泛型

> 类型提供变量
> eg: 数组。没有泛型的数组可以包含任何内容。带有泛型的数组可以描述数组包含的值
> 还可以声明自己使用泛型的类型


```ts
type StringArray = Array<string>;
type NumberArray = Array<number>;
type ObjectWithNameArray = Array<{ name: string }>;

interface Backpack<Type> {
  add: (obj: Type) => void;
  get: () => Type;
}
 
// 这一行是一个简写，可以告诉 TypeScript 有一个常量，叫做`backpack`，并且不用担心它是从哪里来的。
declare const backpack: Backpack<string>;
 
// 对象是一个字符串，因为我们在上面声明了它作为 Backpack 的变量部分。
const object = backpack.get();
 
// 因为 backpack 变量是一个字符串，不能将数字传递给 add 函数。
backpack.add(23);
```

### declare是什么？

### .d.ts 声明文件是什么？怎么起作用的？

[https://www.51cto.com/article/710348.html](https://www.51cto.com/article/710348.html)

[https://segmentfault.com/a/1190000018585303](https://segmentfault.com/a/1190000018585303)


### 结构化的类型系统 structural type system
核心原则：类型检查基于对象的属性和行为  “鸭子类型”或“结构类型”

`结构匹配`只需要匹配对象字段的`子集`



## 使用typescript的好处
```js
// 访问 message 的 toLowerCase 方法并调用它
message.toLowerCase();
// 调用 message 函数
message();
```
光看这两行代码，我们无法知道：
- message 是否可以调用？
- 它有 toLowerCase 属性吗？
- 如果有这个属性，那么 toLowerCase 可以调用吗？
- 如果 message 以及它的属性都是可以调用的，那么分别返回什么？


```js
function fn(x) {
  return x.flip();
}
```
光看这个函数，我们无法知道 x 是否存在 flip 方法，是否可能报错

可能你会讲，自己写的代码，自己知道，但是别人接手就不了解。

项目中经常存在一些一开始没出现的兼容报错，只有当特地的配置下，才会出现，这种情况如果在一开始就定义好`type`，使用`typescript`就可以有效避免
```js
// iyb-sky-h5 notice页有一段这样的代码，某一天忽然有人找我，说页面点击无提示无响应
if (pattern && name) {
  const subI = val.find((i) => i.name === name || i.dataBind === name);
  const reg = new RegExp(pattern);
  if (!reg.test(subI.value)) {
  // if (subI && !reg.test(subI.value)) {
    toast(message);
    this.localByPrefix(firstPrefix);
    findErr = true;
  }
}
```


### 捕获运行时的语法报错
最好的还是要在代码应用之前，就找出问题  => TypeScript 这样的`静态类型检查器`(程序`运行时`值的结构和行为)

### 捕获合法报错
以上代码，`user.location`是合法的，只是返回为`undefined`，而在`ts`中，会出现报错提示：
```ts
const user = {
  name: "Daniel",
  age: 26,
};
 
user.location;
Property 'location' does not exist on type '{ name: string; age: number; }'.
```
拼写错误：
```ts
const announcement = "Hello World!";
 
// 你需要花多久才能注意到拼写错误？
announcement.toLocaleLowercase();
announcement.toLocalLowerCase();
 
// 实际上正确的拼写是这样的……
announcement.toLocaleLowerCase();


function flipCoin() {
  // 应该是 Math.random()
  return Math.random < 0.5;
  Operator '<' cannot be applied to types '() => number' and 'number'.
}
```

逻辑错误：
```ts
const value = Math.random() < 0.5 ? "a" : "b";
if (value !== "a") {
  // ...
} else if (value === "b") {
This comparison appears to be unintentional because the types '"a"' and '"b"' have no overlap.
// 永远无法到达这个分支
}
```


### 类型工具
> 类型提示：代码补全
> “快速修复”： 自动修复错误


## typescript编译器——tsc

```bash
npm install -g typescript
tsc -v
tsc 指定Ts文件

# 报错时仍产出文件
tsc --noEmitOnError 指定Ts文件

# 得到 ECMAScript2015 版本的目标代码
tsc --target es2015 hello.ts
```

显式类型

```ts
function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
 
greet("Maddison", new Date());
```

### 严格性配置

CLI 中的 `strict` 配置项，或者 [`tsconfig.json`](https://www.typescriptlang.org/zh/docs/handbook/tsconfig-json.html) 中的 `"strict: true"` 配置项，可以一次性开启全部严格性设置。但我们也可以单独开启或者关闭某个设置。

在所有这些设置中，尤其需要关注的是 `noImplicitAny` 和 `strictNullChecks。`


> 你的程序使用越多的类型，那么在验证和工具上你的收益就越多，这意味着在编码的时候你会遇到越少的 bug。

> 启用 `noImplicitAny` 配置项，在遇到被隐式推断为 any 类型的变量时就会抛出一个错误。

默认情况下，null 和 undefined 可以被赋值给其它任意类型。

> `strictNullChecks` 配置项让处理 null 和 undefined 的过程更加明显，让我们不用担心自己是否忘记处理 null 和 undefined。
> 
> 这会让你的编码更加容易，但世界上无数多的 bug 正是由于忘记处理 null 和 undefined 导致的





------

## 常见类型

string
boolean
number
Array: string[] \ boolean[] \ number[]
object: { x: number; y: number }
组合类型： number | string
any

## type assertions 类型断言 —— as

> 用于描述更具体的类型，可以使用`any`

```ts
const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;

// 尖刮号语法
const myCanvas = <HTMLCanvasElement>document.getElementById("main_canvas");

// 连续断言
const a = expr as any as T;
```