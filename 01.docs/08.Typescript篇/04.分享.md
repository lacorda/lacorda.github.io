---
description: 分享
slug: /94dac3c
tags: 
  - 分享-ts的泛型与类型体操
---
## 一、类型

### 什么是类型
是编程语言提供的对不同内容的抽象：

- **不同类型变量占据的内存大小不同**：boolean 类型的变量会分配 4 个字节的内存，而 number 类型的变量则会分配 8 个字节的内存，给变量声明了不同的类型就代表了会占据不同的内存空间。
- **不同类型变量可做的操作不同**：number 类型可以做加减乘除等运算，boolean 就不可以，复合类型中不同类型的对象可用的方法不同，比如 Date 和 RegExp，变量的类型不同代表可以对该变量做的操作就不同。

### 类型安全
保证对某种类型只做该类型允许的操作

### 类型检查
保证类型安全的机制，可以在运行时做，也可以运行之前的编译期做。这是两种不同的类型，前者叫做动态类型检查，后者叫做静态类型检查


`动态类型检查` 在源码中不保留类型信息，对某个变量赋什么值、做什么操作都是允许的，写代码很灵活。但这也埋下了类型不安全的隐患，比如对 string 做了乘除，对 Date 对象调用了 exec 方法，这些都是运行时才能检查出来的错误。

`静态类型检查`则是在源码中保留类型信息，声明变量要指定类型，对变量做的操作要和类型匹配，会有专门的编译器在编译期间做检查。

**动态类型只适合简单的场景，对于大项目却不太合适，因为代码中可能藏着的隐患太多了，万一线上报一个类型不匹配的错误，那可能就是大问题。**

**而静态类型虽然会增加写代码的成本，但是却能更好的保证代码的健壮性，减少 Bug 率。**


## 二、TypeScript的类型编程

[示例](https://www.typescriptlang.org/zh/play/?#code/PTAEgDvRVZUbx9Gj1Rvn0Pt+AoEoBmBXAdgYwC4CWA9tqAIYAmlAFOQFzaYC2ARgKYBOANKK-aCZsuASkYsOnANzJUYLHiKkK1OvQDO+ToWwBzXv1CbtescZ26ZcjDgIkyVWgwrYAngYHk3I0AG9roIGgnOz4mJwOoADUfDJoAL6yaID0poCAxoDbNrCAIW5wSNYKdsqOADwAKgB8aqClHtVi1X4BQSFhEaB00Xw+5OrV1onWaXCAaP6A0F45CCgFSg7UZaDsAB747NiUvUKSoAA+RloWlc41fAKl9aWNQaCE6O34rgAO7MS35KAAvJ+gAOSbXN+gABkgNA9yeLz4Hy+vwk-x8-iuVxa4TIHRirG6vVKMiu8VAyCuNzuj2eryh7x+5j0AOBoJJENY5Mp+2p8IJiMCyLaaK6FCxOKCePZgXwAAtOMQAO6CdjSgCinAlnBo3wAktgAG7kAA2hEoFE4uhYq3w6m+IhkAzQgEzFQBfio5AL+KgAdTLKmuDIRw0ACMvAATBaPapvl7vrxvsZzXEwJ6fczOJHZNZrYAAOUAVHKAFfjAHtqgE-tQCGMYAF81TgD0dQDkBoAeBSyzuQWs4oGIrAAVl6Ppcgs4fcKTj9faHO7gBAiORR253Eok0NN7KBdKEAAoSp6ce4ANR1mHY8yWKzWvQASuxcMROJRilT9C5XOVeABpdiuBbLVbrPYmXSVesNtmT5Qz-Dz4iLiua4bhcW5PnuB5HieZ68F4l43neD7bs+ADWd4QhUNAfqcvBoa4Ai3q45wANqEQAuq2nKhCidaNsReFkZayCHtg6jENq7AAHTasQug0L+-6Aa4q7auuWGNrG3y4OaFpAA)


### ts是js的超集
TypeScript 给 JavaScript 增加了一套静态类型系统，通过 TS Compiler 编译为 JS，编译的过程做类型检查。它并没有改变 JavaScript 的语法，只是在 JS 的基础上添加了类型语法，所以被叫做 JavaScript 的超集。

静态类型编程语言都有自己的类型系统，从简单到复杂可以分为 3 类：

### 1.简单类型系统
为保证类型安全，对变量、函数、类等声明类型，比如：

```ts
function add(a:number, b: number):number;

function add(a:string, b: string):string;

function add(a: any, b: any) {
    return a + b;
}
```

比较死板，得申请两次，如果类型能传参数就好了，传入 int 就是整数加法，传入 double 就是浮点数加法。所以，就有了第二种类型系统。

### 2.支持泛型的类型系统
泛型的英文是 Generic Type，通用的类型，它可以代表任何一种类型，也叫做`类型参数`。

**声明时把会变化的类型声明成泛型（也就是类型参数），在调用的时候再确定类型。**

```ts
function add<T>(a: T, b: T): T {
    return (a + b) as T
}
```

但是这种类型系统的灵活性对于 JavaScript 来说还不够，因为 JS 是弱类型语言，变量的类型是可以随意变化的，所以就有了第三种类型系统。

### 3.支持类型编程的类型系统

**对传入的类型参数（泛型）做各种逻辑运算，产生新的类型，这就是类型编程。**

比如，我们要返回对象某个属性值的函数

```ts
function add<T extends number | string>(a: T, b: T): T {
    if (typeof a === 'number' && typeof b === 'number') {
        return (a + b) as T;
    } 
    if (typeof a === 'string' && typeof b === 'string') {
        return (a + b) as T;
    } 
    throw new Error('Invalid arguments');
}

function getPropertyValue<T extends Record<string, any>, Key extends keyof T>(obj: T, key: Key): T[Key] {
    return obj[key];
}
```

这里的 keyof T、T\[Key\] 就是对类型参数 T 的类型运算。

现在 TS 的类型系统是图灵完备的，JS 可以写的逻辑，用 TS 类型都可以写。

但是很多类型编程的逻辑写起来比较复杂，因此被戏称为**类型体操**。

## 三、ts的类型运算

> 静态类型系统的目的是把类型检查从运行时提前到编译时，那 TS 类型系统中肯定要把 JS 的运行时类型拿过来，也就是 number、boolean、string、object、bigint、symbol、undefined、null 这些类型，还有就是它们的包装类型 Number、Boolean、String、Object、Symbol。复合类型方面，JS 有 class、Array，这些 TypeScript 类型系统也都支持
> 
> 但是又多加了三种类型：元组（Tuple）、接口（Interface）、枚举（Enum），字面量类型，以及4种特殊类型：void、never、any、unknown

### ts额外的类型

#### 1.元组

`元组（Tuple）`就是元素个数和类型固定的数组类型

```ts
type Tuple = [number, string];
```

:::tip 数组和元组的区别
数组类型是指任意多个指定类型的元素构成的，比如 number\[\]、(number | string)\[\]、Array

元组则是数量固定，且每个元素的类型固定的元素构成的，比如 \[1, true, 'guang'\]。
:::

#### 2.接口

`接口（Interface）`可以描述对象、函数、构造器

##### 2.1 对象

```ts
interface IPerson {
    name: string;
    age: number;
}

class Person implements IPerson {
    name: string;
    age: number;
}

const obj: IPerson = {
    name: 'guang',
    age: 18
}
```

##### 2.2 函数

```ts
interface SayHello {
    (name: string): string;
}

const func: SayHello = (name: string) => {
    return 'hello,' + name
}

```

##### 2.1 构造器

```ts
interface PersonConstructor {
    new (name: string, age: number): IPerson;
}

function createPerson(ctor: PersonConstructor):IPerson {
    return new ctor('guang', 18);
}

```

对象类型、class 类型在 TypeScript 里也叫做索引类型，也就是索引了多个元素的类型的意思。对象可以动态添加属性，如果不知道会有什么属性，可以用可索引签名(`{[key:string]: any}`)：

```ts
interface IPerson {
    [prop: string]: string | number;
}
const obj:IPerson = {};
obj.name = 'guang';
obj.age = 18;

```

总之，**接口可以用来描述函数、构造器、索引类型（对象、class、数组）等复合类型**


#### 3.枚举

`枚举（Enum）`是一系列值的复合：

```ts
enum Transpiler {
    Babel = 'babel',
    Postcss = 'postcss',
    Terser = 'terser',
    Prettier = 'prettier',
    TypeScriptCompiler = 'tsc'
}

const transpiler = Transpiler.TypeScriptCompiler;

```

#### 4.字面量
此外，TypeScript 还支持`字面量类型`，也就是类似 1111、'aaaa'、{ a: 1} 这种值也可以做为类型。

#### 4.1 字符串的字面量
> 字符串的字面量类型有两种:
> 
> 1.普通的字符串字面量，比如 'aaa'
> 
> 2. 模版字面量，比如 `aaa${string}`，它的意思是以 aaa 开头，后面是任意 string 的字符串字面量类型

所以想要约束以某个字符串开头的字符串字面量类型时可以这样写：

```ts
function fn(str: `#${string}`) {

}

fn('aaa');
fn('#aaa');
```

#### 5.四个特殊类型
还有四种特殊的类型：void、never、any、unknown：

* **never** 代表不可达，比如函数抛异常的时候，返回值就是 never。
* **void** 代表空，可以是 undefined 或 never。
* **any** 是任意类型，任何类型都可以赋值给它，它也可以赋值给任何类型（除了 never）。
* **unknown** 是未知类型，任何类型都可以赋值给它，但是它不可以赋值给别的类型。

:::tip any与unknown的区别
1. any 和 unknown 都代表任意类型
2. any 禁用了类型检查；unknown 仍然保持类型安全
3. any 因为绕过了类型检查，所以它赋值给任何类型的变量，也可以从任何类型的变量赋值过来(除了 never)；unknown 只能接收任意类型的值，不能对 unknown 类型的值进行操作
4. 类型体操中经常用 unknown 接受和匹配任何类型，而很少把 any 赋值给某个类型变量
5. any 会失去 TypeScript 带来的类型安全，容易引入运行时错误
:::

### 类型的属性
除了描述类型的结构外，TypeScript 的类型系统还支持描述类型的属性，比如是否可选`?`，是否只读`readonly`等：在属性前添加`-`则取表示相反属性

```ts
interface IPerson {
    readonly name: string;
    age-?: number;
}

type tuple = [string, number?];
```

### 类型运算

### 条件：extends?:

TypeScript 里的条件判断是 `extends ? :`，叫做条件类型（Conditional Type）比如：

```ts
// 类型参数的运算
type isTwo<T> = T extends 2 ? true: false;
type res = isTwo<1>;
type res2 = isTwo<2>;
```

### 推导：infer

如何提取类型的一部分呢？答案是 infer。所以我更愿叫 infer 为**提取**

比如提取元组类型的第一个元素：

```ts
type First<Tuple extends unknown[]> = Tuple extends [infer T,...infer R] ? T : never;

type res = First<[1,2,3]>;

```

### 联合：｜

联合类型（Union）类似 js 里的或运算符 |，但是作用于类型，代表类型可以是几个类型之一。

```ts
type Union = 1 | 2 | 3;

```

### 交叉：&

交叉类型（Intersection）类似 js 中的与运算符 &，但是作用于类型，代表对类型做合并。

```ts
type ObjType = {a: number } & {c: boolean};

```
:::danger 注意
同一类型可以合并，不同的类型没法合并，会被舍弃

常见的场景：

<font color="#FFEBEC">当 组件A 大多数属性都继承 组件B 的属性，但是其中onChange方法参数类型不同，这个时候必须先将 组件B 的 onChange 排除，再新增 组件A 的onChange定义</font>
:::

### 类型映射

对象、class 在 TypeScript 对应的类型是索引类型（Index Type），那么如何对索引类型作修改呢？

答案是通过 `in` 作 `类型映射`。

```ts
type MapType<T> = {
  [Key in keyof T]?: T[Key]
}

```

`keyof T` 是查询索引类型中所有的索引，叫做`索引查询`。

`T[Key]` 是取索引类型某个索引的值，叫做`索引访问`。

`in `是用于遍历联合类型的运算符。

比如我们把一个索引类型的值变成 3 个元素的数组：

```ts
type MapType<T> = {
    [Key in keyof T]: [T[Key], T[Key], T[Key]]
}

type res = MapType<{a: 1, b: 2}>;
```


## 四、类型体操

### 1.模式匹配做提取
> **Typescript 类型的模式匹配是通过 extends 对类型参数做匹配，结果保存到通过 infer 声明的局部类型变量里，如果匹配就能从该局部变量里拿到提取出的类型。**

通过 `extends` 对传入的类型参数 P 做模式匹配，其中值的类型是需要提取的，通过 `infer` 声明一个局部变量 Value 来保存，如果匹配，就返回匹配到的 Value，否则就返回 never 代表没匹配到。

[试一下](https://www.typescriptlang.org/play/?ts=5.5.2#code/PTAEgA5RABkQitHh9ROZULKJgtBUAvGg15UFj-AoEpD+8oBSuApgB4AuxAdgCYDOA-AFzJKAkSoLWmgMP+CxioFgJgcfjQASyoAzYgCdQgB41AcGaAQt0ACOoAuEwN4+gaPVAG8qB5xK5JAmEqAV+MB7aqImTAu-KANbQW7suMAEYAdOgAOkgPYBbYXWIFU0AeBWxyAE93YlAAcWJyADUAQwAbAFdiABVI4gAeAAUAPlAAXlB80DJKWjpy7z8A3PMpUGT04mKGVtSM0CZQKmIANykAbgcIqNj4toyAJWI6NJTyUunEnqycgvr-PIByAHM0pKpD-cLC8cdQACYAWld0QAdTQBG-BUAab3BAKjlAYUVAAl8wjl1gAxYSSOjkXIAQUk0iq1HooDSVAA1lQvAB3KgAbQAusUyrD4RREbUcc1pGCIeQADSgFyMlHorG4vF40BdamQvoDYZjCbAuLkbnkBZLFZrYWi3I4py0260gDMBOuk2i0vBkPFy3Ityl8Rl+KuDjwD1ubjeCkAAOaAOBUfgCgVNhQAZJKQmFwyqkmrItEY7HGtbE73VJE4xkuZkBtn0ymgN2QjldROrfqDEaSNVC+KpnWSsqu91QuUK5WqwXO3PF-N6g3kVOyis3B5KlygYlJcIudxedwACgAlE7ovk+8TPSSw7Vo6yg0SvQjffjOaAV-0Q0vw5H4+K6X6Wdjk6A97yMwKR+U+7W1mP3BPS4qVSbL3fa-qyneH82zfcACztp23Z0AAFsIYjkEOl4AMpgRBE6bj6SKzoGBLBouSHkse64dhh05rihVD0ju4gtHux6num-JZpW0SweBYqLLqaz0fBcKyvKT7NuqoCsYxEp1mUfHfi+eBKo87bQeQkiiIcLiQkkkjkAA6sI5AgVBPFSYp5B0Kp6m5FJU5kqAkIyWc9L5JIxBiMIpChiZZmyYSvHSQ5voAAYACQAN5WTZdkAL6+U5ZyBR5q7Sb0-RiKkATZlM2lKXpakgTeQnkDpKUGUcJxnKApw0KANBeGc+z0rlpznC+WmZcl+lpUxKwfq5WUNbklX5YVxWlecFUlWVolgOJFqueZcnWe4KRJAAxsQmnAgsU2zcQRmGW5W61KFhz0iC9TuUi230pkXgHVt0nOWsY1naA3k+fG-m2aQwU+XtvgvfG0FpGIT3haud2PUFvknS9X0-UFEX9EZCXREt01zelJ7EMtc1rQARDEeWHMcVX7LUABGiyrGIMmIiItQMGj9Jo5T1MACK9QNhxozVi3I-DxDvmscMrejST4zNVOgDTQtowzZxMyz1xifcbagIA3cqAF5egA8FpemQyT4RlzMIhwgVCRk3dtLkG5tt2+buRMvfsoDWwAPjbAA6VB2475D7H9XTq8ImvSdrutQnuxRQ9JMOgF7Ph+3riPh1rOt6x1OP5aAycpzbrNTDH0kujZ+sbZhpkXWcxt5-hd3Wy7+xOxXDtux9pHSHuHthxrRnZxBuSB7y0O0c33tt-xzFlJnkj9x1qfJ0zFyh8P63Gb6RulMPkdQsPo9GZc08a9HLfSWP49MynU+mmAf4SaA6CAL+KzyAEPKzyXsK+SKUkPjxFIdC5CCKIzTdn9UDN5DCFKi5X+39Tb9kjIpQ4dB+jxlhFAwcpRiiEVXHA2oVFMyh0fpIZ+r8ISIwfk-F+lAIS5H7FQHB-QjoFUOMQdMaQfCE0kAgkoxQjaYMIbgugXNCzxCwTg4h78hyIILuNIaoBT6jUvs8EI994gLHIGkSQVBshRA-l-H+X8AFALWCAm64DGSQOgQVKg4R8TMOKBbBRSiVHRC6PIxRyjgToIvDxex1icj5gLOsNxjjVFkIoSI2S5ibaTzETxYUCwxBWT7O-aJ7g6AuRuKnfY1kxDW1NqiYg4QvBiDqDEpJ49k5dDiXQHEKSbL7DxM4misjGJRO8PEnYMTEnJNSek-OmTsm5JKdgQpRS8nxJuj5UAqTmAiHrt0dooB7YohoAFQYNBAq9L6anLosxiDLJWcnapmzx7VOuLUyJJTxT1iOQ09+wzRn9HlAMAJ+xJ6BXThqORNljmLBahE155zciXJsmM-YTgnDlVuS-fo9zeruxNEAA)


### 2.重新构造做变换

> 通用 `extends` 做类型 约束 或者一些 拆分，再
> 1. 通过 `infer` 提取出来，
> 2. 还有其他手段做一些 **过滤** 和 **变换**，比如：
> - 通过`...`解构
> - 通过 `in` 遍历，再通过 `keyof` 获取索引，再通过 `T[Key]` 获取值，
> - 通过 `?` 可选属性, `-?` 取消可选属性
> - `readonly` 只读属性，`-readonly` 取消只读属性
> - 通过 `&` 交叉类型，通过 `|` 联合类型，通过 `as` 类型断言
> - 通过 `as const` 字面量类型


[试一下](https://www.typescriptlang.org/play?#code/PTAEgdTQRv0LH+ChZKACgVwM4AtYBcCeAHAU2XQwB4BBAJytEIA9tCA7AEzVFBWYGtmB7AO7MA2gF0ANKACiAG0IA+UAF5QIgHSbqVKXMJiA3PDxESmAEqE0KWdhVnyIgIxSATFIDMk0ABYFRhDAAVWZMAEsAM2wcAmIQ8KjKGjpGFnZObj4hUW89JVURPSlNdW1DY1jQeIxI7EtrW3tq2rJnN09vAAZ-eEQALTD8GNMB-DIAeWZiBiY2DhFMgWEpRezvcewMQloZtPnV5a5eJeYxfNBYTk5J6dS5tTDmCO3QG4AxMKo0bClH59obgBlQgAY34bDElyu0IA-K9Ni9dvcRH8XhstlQPl8fqBUQCEVRgWCIVDoWTQHCRCJ3p9vlJ0dssd9vNSpkTwax6QT2RCxKAAFziC7kkVXflqcqk0Vk4bEUb1Gx2VSjVouVwsgDkAHMUABDZhajVSDWscGGs4BfqDVyy0CjVwTKYpWbpA45LkY517I5ZYTic5Sm5e5F415TJk4kqhm71bCQ0Vwhk7O7pFFPNEEiPFTTRgmx+PSziU1mELPwjER7wle2Owixj3bWMKMTi8RSwucVuSkxy60KxrK62qiTuDwSHwSACsmp1+sNxtNBqNoA1YTQy41ACMrNgNxEqGE0hqLb0wIB1bUAZN6AJjk4IFQABhXX4MLYXWyMIAL0IgOwVFtj+fV93y-H8qDIUDg3Sb4DwNc4IKRdIAAMABIAG9QwjABfNDQ1jTDEIpUAUNQoJ8CIKgQV1NBCDICMFGw1C8II8VQICHsHyfF830-OsrEVewAK44Dv1-MhtT1JcejvR8AFtCFkR9qP-XU5IUqiaPglMOGgx4tQDaFNJdDhiNDAAZQgokwgB9HD01ocwwi1DBsAY3Cd3w9srjhYjzMstDSPIyjqLIBynOwei0Nk+TFJopsPNFFjfzYyoorU6j+yVDjVJisTFy1Ky8oKs0NSkxAABEqH4fBARQTdQNtCqqpqurRMM70dINKRmra+4Or0+wpR6pDbP+ZAqAssJ6AY7rf1cuzQBqiIIkm-DhRFOFGuq2rQLIYikHG5aprQxbDvwrrtt-JREqoZLTE2jL7E2mawJNM0AD8Po3N6SstMBAF-FcBT1ACgyLSagdTk5honYkGiDYcGUEh7BaO4EFII4N5UewMJwSkcH9KuTHmDRhCOAAChKXUqC1NBxVDcG0AAShUJQ3OwFAqGYAAVSpPKLUAKc0KmadbEoGbx6mxGZ5QlEsdnOZ50xxSmAA3bZbuIWGwepxGWDqPjGnsLX4Z1pGyDJ5gVMIcU+ulpRN34fh5H1KRmER7cqFKsBACJfQBUfUAbx9AGj1IGAFkn2fA1bTDsjdImTcACt0dAfgE9BcL7FQtbOBEABpQhcFxZhQB4fP+AiV4E5bNRxgT3P8-WWu89wBv47r5vIUwipTHGjhVGjiOtTITPdXFFxQE3cVXEwr2qlBij1Kb20Au2ILCCbuPE9J5PU5BdPVEzqU28L4vS-LmvE6o2fAvUsgm9AAAyUA+ubcVz7bjuu7iOfV6bh7VGX+e1F16Z1nAaUeUg8qT2nr9UAXN+CWF1IuWQuBbRwIQUg3AZAubnFAKhKU41EHgmQWoO+jwT64DLrAquXN35GE7radBRDcB-1gfAwghDmDIKHlKS2ckba-l0kYaEuotTW1AG7GSHs6EzzgUgKm2M3yoP4HIqgCjZBYPOHg6ER8yElwoeXLmYgYTihoU3D+toVFqJYbI+RYQ3zcOhLwsRfUhFXBEWIiRUjYDQKBnAkOKBXybnkEo-xgT5AaIzlKAAtAQjBJD87Hz0ZQwxJj37eM-qAUJuogm8QaJlVhWSckOKuLEph4irb8JglqVxnB3HK3durbxMi2EAEcUCfEIKwJRlg2kdNYBE-eh9SFFySQYsQUTjGwLSfQ9iPT2njVYP2AcrC5l9OKZwJxkyXFSjqeIhpN0mkwI+LYbYAAhXAAA1N8KBCCK0ILaY5TAqDnKubIG5dyN5J0sGCKg-S+pSH1LgBQUhXnvNiJooZCTdGnwronPmoBL5vzMUnUFtzKhwjvsrQgasqAFnJK-Ru9d0mwEeE8iIuoQTECQNsNA4JcE8IqU-ARBoakItEfUyRjToQYBTpuXAlTdLiDoRkx5jYDaZVFc8y51y0VEDINSr4uMmVVNAAAHz2Zyz2BggA)

### 3.递归复用做循环

> 不固定层级，不固定数量的情况下，根据条件做递归


[试一下](https://www.typescriptlang.org/play/#code/PTAEAUCcHsFsEsDOBTAXAKHSUARZyAHKOJZANQEMAbAV2QBUBPAtdAF2eV3yJgRUq0GnADzhQyAB5tkAOwAmiCH1IiasgNazoAd1kA+faAC86UOYgTpcxcpIoR8WQDNkkUILpMWRsxf8A-B7UXpxWMgpKxPzIapraevp+-imgQXiE0aSewiwiOd7ISampqMFChckpZbLIAG5uANyYHCzcmSooAErIiDRUbCbtvPbkIbmxWQ5TsT0AxtCQ8iKIbJBOAOYANKAUsoyGhs1YYBkjMQWcAEzsYWczlyxXIvRGxqBV9OE2UZ2xTq53I8ih8Smlhg9xoVnsDiiUyvRjq0uPc-sCrj0lO9UaN0WI-vjRoSYiJZDRYAAjNyHfTHbCAB1NACN+gCx-zDYHoNSAoACCkEgGGRoA5bh5fJEvPcUgitnUWl0sgA2gBdN6giwS76RUAKgFuUAAMXgXLYOwAdObde5MWwlWrUkEFebTcKucgJSJrfodobjbaqv4yhKkWEXaLIJj+oN3qG3WKFQBGLZXLYAZi2ABYtgBWFV0sAASVkc1o8l6tzaheLNFLiHFfM1Mvi8uV3qc8nzMlgqqqGqlP21loNRtWZotLj11qV-osQXziAAogBHGjUEQ+kdDhQd5BdhtKNZ0af20AH5BH6qgSsl3oe3omzftztw0qgZzUFDBisL5er7k7ABCqoABTcnuoD-uCp6gGUb5UCgACUoAAGSgEBEF9lqoFBFBMHvsg8GflwV7Vr0EYDEMxE1iICY7MmoBpqAmagDmOzprSLRhJRpG9JGVwUUW161jRoB0QxTEsaAABs7EnEKO7QA026wOWXA9LACnIEpdaStYWqygkipKjsSk7GRgwYY2cp6MqQzKt2-i9rptg6uO7jrveTqDpO56zt+K5UGuw73kpRgWfukCHmCgRyepimdreG4mXJfQDM+UVlGpGladaxmdjsjrmmZra+mlAbJZGhExVlnZmUMmVxTu1GJsmyYpkZIkydg-40PAVDyBKFCMCp4E9X1A2MCIAAycgbGwAAWYFkpSbg7FU85UFw7z6fKq0OfWYWgNt1m2u8dkmD2fIKgA5BtsizXNV22gd013fNdopEEGrnmU3W9f1fKDVNM3zTs63IPlToSqDG25hxbS-WNfK1e8CP-ZAgNZp1YCAOragBk3oATHKAN4+gDR6myYA9AQVAUHMbpUFQw0U1TNPcnTIgAMprGBqzrHdu0WPqfBc2smx8+Y9DQELPMbPZJQczp0pKAABgAJAA3oO03OGwAC+asC3Auvq65QrwBsc064r57RSrquazravi4bjPU7TAVdKb5venwOzi-o2uW1FFhlHLlXO8zdPI3JlMuyzAVXRsK53aACd7BsyeJxsV07PHGdZ6AV3yNAd1XVjoBy5s4sAKqyPARfDeXd1VzXRfs5zB3c5sMvmHLYE24O7mG15d7+z5Q7GqAAA+ZfC430DV7XsgJWwpVB6AtScsc9czxsTcL5HDc73PzeL1dc3IHT0Al3mcmcigcsM-UIrIHLrfy-2He8+9tXt9vQxXSXQwqg9wOn3Y2A81ZD1WP7d60UYwvxyqAG24DVZmX9r4MEGUeIDFDo-V0ctI5wLWCIU+58qCX1LoAIl9ACo+iTVkskzg9AoIXWQVAhrDQYcgJhRdWEiAAPIUgAFZgXmIsZYH9ti7H2IYc6-h+FCIOnsIaYIgiqythYSAnDmGsO1AAaWQIwUAThQAaH0dAZwoA5FKgwIHVIciFR6MYE9JyShoCCOQHMNgajA5BDsQ4pxCsDTqA8QvLxNjzA+MEfY-RfowlhLKBwrhLCJq+OiSvWJ0ELGRL8eebW30164Mqq4oR7xVH+AoGUUpJQKQVNCXMGp6TzDODKEBRCxgjAFyLpnLYoT-DyHqQ0-waBQCVIGakFOd0yjiJ6SUXJAzZk2PmakRZoBcm5PYTwRhWjGCRwSVskQRT2JAA)


### 4.数组长度做计算

> **通过数组类型的构造和提取，然后取长度的方式来实现数值运算**

[试一下](https://www.typescriptlang.org/play/#code/PTAEEEBNIKAFwJ4AcCmoBCBXAlgG0uAE6ECGCAPDKNaADIoB2A5nABagoAecjkAzqAaYAtgCMUhADSgqNAKK40AXlCYGAawYB7AO4Nps6kUIduvAWs26GAbQC6oFfZgA+RxGI2A5IuZsvDlw8DPx0jCzshjTUAPweJlHRAFwYOPjGZOT0fqzSCijSNgB0JcZ5inYuANwwtYioENDkAHIiAIymwaFCYhLSrcIATJ3mgiLihG4qUcUlWHgExJkDbS6SJUXz6UsUA4Mudt6+EQE1dchoUJAASih8mLhw7lfkAMyD0oMArNW1MCCgADKmFEcFIAGM4PALkCQWCSJCWu0RiEBD0Jv0RMMgqN0RIpjJoltFqRdu03DjUaBZkUSMQ2iliRkyUM1qANnTCIMUtgGAAzCSgW58OB2RI0OLCuBHcL+MXRZKCFAANwkZ3qaGBoIhcGFDyeKi18MRr1e0ja+zOAIAsvrsEhcAhoQ1bXB7Y6kcIOpTuuM+qA9ijfb0pEK7vqgxYNNo9PZ3PYplFAz6BAAGUCS8OPGU5ALi6gpV3ulltaRGnWej6gVaFDZMnaemvskp6x6VdUwosOhCtg2gLses2gQYj37-MAAEWwyuwkBQzrQU5nc8bkbGIcxQzXeNDAGEtGo4MY15YY7YHE5Ko4k8iU6B03F94fjDmTvKFQXQEvZyhyOWEXAjabvswGFKe1jSBsT4MEexDtucDTfnOvbuEhv6vKm0g-Gc45AmC2QLnhhDZJQ0SAmCa4ioQvJMJIUTQbBJh3uBsYXtSYoEuRTFmFSAAGAAkADeVE0QAvkJvICiYUqibxGZESRUq1iUDFlKo0bWFeKSqZ4PiyqweaEVx2QoYa+GMOQXgABIoLguBaKAADqWiEPgXhjrhADihAoCQPCEAAKqwJAMIR3m+f5QUhaRNArNufpSDeW53judHRDp3FdFGVisfGHHuHFd6BlEcR8iQuB8POioZa+cprns+byWCmBVR+oDaQeMEvnpuaBDxoQrI10SleVlVDTQKThX5EhRQwQEBliylFBl0gsQw8EIWgU2RcFDCmaA20zbtbzSAALGOGoHT502BbtvbDCoh23dFABsZ1jgCABi2CiFoDAIuC2CEd9v3-eCgO0FoWhIDF1AAAo+cqx7MRprEGOlmDEIwjEnqj57ozQACSIRcMj-XZWecaXgT1ADPFIbuG0rjuMTc6cN1xx1UVIglaAu6Yz5XW6ZzBnvp+IN-QD2CQ9D5D81jQuhjSCMqmpUEC9jxh2EtrOk8Qq149rC3CG4m2gBLYOA569MTASFtSzLMM2G0Rv2IURsDB5AJtIAgAy+4MPuvD7Xw+wAHH7QeDL7ryncDP2S+D2D7fbifkKH1RAA)


### 5.联合分散做简化

> **联合类型中的每个类型都是相互独立的，TypeScript 对它做了特殊处理，也就是遇到字符串类型、条件类型的时候会把每个类型单独传入做计算，最后把每个类型的计算结果合并成联合类型。**
> 
> 条件类型左边是联合类型的时候就会触法这种处理，叫做分布式条件类型。

[试一下](https://www.typescriptlang.org/play/?#code/PTAEGEEMFsFMBsDGkDOsBQAXAngB1hDAsmgDwDKmATqLAB6awB2AJiqCtQJZMDmAfKAC8odKHGhKNeo1bsABgBIA3jwBmsGgBlYazAF8A+ivWbQAJS68AFgZNMNNc7E775YiQH5QS5Tr36KgCquPhUJLCkljaY-IHKUHBIqJHOnHHuEqAAXJLUANzoWHgEicQpaQCu8JjChEkRpADkkJCGre2QTfyFxfj15WgAglRUpB4j0gzMbKCVTADWTAD2AO5MANoAuuiCIpO003KgG6Y0AJKM0AA0oAB0D2cWLpiTO+LeG2XJZJew0KAAGQcbh8fi3B53b4RSZRF6TfjvHInLa9HD9aEpSZVGp1THDUakDYtNodVpNW5NABGVMMNLpVIpoCaiEQhlZ7MQTS2PSK6NKRB+sCCTC4yyYpD+AJkM3YnCoPAEdQ8UsOslmvie-gMxlUDjM0Vs8SeaQM8lEWW8vm18RCYUahti8XxwtF4rh6TcFokuSlaJKAyFIrFTBxtRELuD7pJnU6TVAAB9mfSU4zE8yOZmubz0CBQOcUFGmHyAwWi6QhrcAEJ1IZ7DziIZq2WgIYNrKgT5VrbN44bIZIjsd7xqSDwNDtofiXLUSoYKfIpiwABumhL-TLbtDLmq4fzha3zS6CepTRPXJPLG6-o3B5DYYATHVNyGicyuunT5+uTzenmACovEWfQEIBnDlpWoA1vseytuIMrHE23jKKAkC5JBVK5FW+iLiumg3qBQFbmGdRgZg5YtPGSZftR2Z-mAVYAKIALIgVBLHjFkVbwMsiALL2szyoq1ztox8D-MwtQIYJoK8NsIlZMxywsFwahcJo7DSXKsnbLsdS+NxvELEYupiRJTCYBsTCVNAVKaFs+gALSOSoSkqWpGlWTZdlUA58i9GxdnQCRIhMcxzS8JUkB8EyxKtF0lI0oyWy3MSqyQFQooxZSKCVKyLgoNyOZ5kM8DwOAyy2TwkCYCGKBsRVVVMDVr5NlpIIKnw1YCdpnVKkI7ZJm2WRJlWg0+CoQzxNhmQSEmBnxFN-liGxpXlZVVLVbV4ooBWPUdcJUH7UJfC1rBbVHLMw1eBAG1ba1txrY1m3NdtTC7YxdCIPAlQsJEVaPfwQPtrkS6rlQBGtmVz33TtIVQ+tTUtTtzRDFRzJVujTTgNeQA)


### 6.特殊特性要记清
一些类型的特性还是要记一下。在判断或者过滤类型的时候会用到：

* any 类型与任何类型的交叉都是 any，也就是 1 & any 结果是 any，可以用这个特性**判断 any 类型**。
* 联合类型作为类型参数出现在条件类型左侧时，会分散成单个类型传入，最后合并。> **联合分散就是用的这个**
* never 作为类型参数出现在条件类型左侧时，会直接返回 never。**判断 never 类型**
* any 作为类型参数出现在条件类型左侧时，会直接返回 trueType 和 falseType 的**联合类型**。
* 元组类型也是数组类型，但 length 是数字字面量，而数组的 length 是 number。可以用来**判断元组类型**。
* 函数参数处会发生逆变，可以用来实现**联合类型转交叉类型**。
```ts
type UnionToIntersection<U> = 
    (U extends U ? (x: U) => unknown : never) extends (x: infer R) => unknown
        ? R
        : never;

type UnionToIntersectionResult = UnionToIntersection<{ guang: 1 } | { dong: 2 }>;
```
* 可选索引的索引可能没有，那 Pick 出来的就可能是 {}，可以用来过滤可选索引，反过来也可以过滤非可选索引。
<!-- * 索引类型的索引为字符串字面量类型，而可索引签名不是，可以用这个特性过滤掉可索引签名。 -->
<!-- * keyof 只能拿到 class 的 public 的索引，可以用来过滤出 public 的属性。 -->
* 默认推导出来的不是字面量类型，加上 as const 可以推导出字面量类型，但带有 readonly 修饰，这样模式匹配的时候也得加上 readonly 才行。

[试一下](https://www.typescriptlang.org/play/?#code/PTAEEkGcEEDsE8BQAXeAHAphGCA8AVAPlAF5QByAEwHtYBzc0DAD2Q1kslAApy6BXAIb1GAMlD4AlKAD8oZACd+WAFygAZoIA2kDIhTosUOPABKGSPy3JS2E7mHxCAbn2pMdhOcvWATLeM8PiERF30QbABRAEchLQMPKBi43GgAGlAAIWIybmgmVnZOLNlQAEZQNV9pcW5MgrYOLny5CqrJVwSjSGTtbwCe2O1cckFyDMcwrqihrV9UjOzbbgJCbmkSYnwGoubSttBqnaaeVfXSLePi+tbKw8lEUCfSxWU7zR0MTvdu3rn+shJWbzUbjUCTToRKAAVVgAEtaNMYfDaAsSmRoDlHs98ixGsVoNjns85ABtTIAXSuXFJ0ApROJjLkH10DMZzzUrz07KealgGAAbhgFG5DNhYQjYN4rDZAZAJajyNBGAAfCiZchhH7ilFSiwy-xyhWwEbKqYgKAAOUFwqRkGtQoUq1spPwVLxu1ApP5jqpci5720rLtDuF0usA1DTp9wq1YqtNoU4eQhuwUYcCCm2vwFmQ9iItm2HpOsH4AFsAEbC-Z3XzfMU5yB5rwWQu5+wQ8LAKD4fhoLR6bUD2AusppXxpADMFNJ5GHdGQAAtyBT6x5h6nS5XhaSZ3P2Avl-S7b3+xhnWQGUXCidSQA6B9oQQKQRlyBqOGwdTVyIDyBUtkSVAS1qGQP5cF-CxZ3nJcVwyLcqwUYhAN5DQgy+UUPBAsDZjRJZL2JFYiHOTYJGpUAWnKWtpGLYoiLWDZLlorgbio9oUNKFlVHkJQMMw7pTwHZMBkE89STHQ4MmnLN40gUTk1THs+wHXAEJ3ClzWAY18GocBYDYBRdAAY2QSV+NAbTdP04VjNM1FoRyUAGW4aFyNcuRuGYNRoUY0B+FgABrWBqAAdxHPlExom86K80BP2-BRQFMXz-KC0LYA4uRTA4iLHTXLBLL0gzbMlYSyEK6zDIwEzJVwABvUABGEOg1AqABfUA1Qamh6CqUA2s0gBxDBkAAeTQOzYG0aZhrGibJWGUaKwAK3IpLquoBRKFwJsFE-OgJkzRy6oZUkOIAaQweA4pHAKruodRQCW1aOOJQQuDqjrmNAAAFOEjIC3BnoyS6nFKUG7hjEViSpNRntJUHV0QNr9Bmkbxsmvp9QjMhZoxhatHq7EprLDA1F2-bXCeQQ6AwGQ+XLRDXAGyFgFm8xYjhBQMEoaY4UgDn+C5nncAh767vgB6npWjJnschlPvIv6AaBmXQFB4g5Chu5Qfy0B2YwTnue257yPMIzNu2in6EOpxjqc4kEaum7QAlqXTfeuKBcNoXjdFq7ZZWwgKThlanfgACUbR5BBeFygyv1kbY79k6nhJsnQGtugqfBWn6dANSFGZzTzDLaghT0ygWAAZThOgpuQfhuemUvy4wSua7rhum-PU3vvNy2dsUfbbcIY7sTO9kIc-V37se03XvBLgxeirgAAMABI6vi6tq8UNq17kPfEty20nhD6XlvD+ko+1VuK44Tv68ERvuYT+-28f5ha+f1-z1Tr0EtybD3oBfRwOdIADgwGgdYagBTUDhJQYurgQAAGEtDvUgD9fgFYtD-R+goagaBICICMhgyAXAAAitA6CgAAWgHBeCjIF1fBnLOOc0CELYCZHmucM6Fw4XtAUL8sCLmoBWCscILDAL2vQXcnQngW1gLtfgJlNrnAAU8Jc-M7zp1sFQGh5Ac5aMXDommWAyC+AAAzGPkKYyAd4xESKkVwMgs5IEYGgWCcgGAX4rhzijW+Yp0GYOwbg-BhDiEJxCRQsJTCCFEMgLgah9ApjTBiVgxhETEmq1Wv3DaW0h6yIOuCI6thNFemnrdOel8L7w0RsSZGXYl6gCUU2UhtAmygHEatMgFTBCtTSAyCsVQmnTB6fgMUZAfhSx6Z0NpNhnyJTcRJCcoBpzmSWZMjw0zDBSyWfMzpNgempn6YM4ZoyOqewWZ0cZK1tkYFTDMx6JzDnKMWQoBQqZxIZDWdOFpNzUbai2YYJ5ezHpLLrECsU5hHS6GgJ81InzHIIsSt9bmggepaGuqSHeiV0g3QSlkDIeLQCoL9F6VBiwMh0khomW5d9Ezws+QCdacKMCoocJ8h5vgXBAA)



### 类型体操的实现意义
> 实现更精准的类型提示和类型检查


[试一下](https://www.typescriptlang.org/play/?#code/C4TwDgpgBACghgJwM4XguBbAPGzUIAewEAdgCZJRLAICWJA5gHxQC8AUFLInoceZQAGAEgDe9AGYQEUANIQQAX1ZjJ0qADU4AGwCuERYM5QA-FFHGuAbVlR6chQF0AXJp37jiqK4BKEAMYA9ghkWNR0jAA0UHAkIEwA3OzsoJBQALLSDBBaehBIWADyJBDRhcAAFtIsHFzF0HykFFDlVQjGZvXGrq3qjQJQuiQA1iSBAO4kVo4dUFb10QB0y70IM1yu8yVlldKOSSng0JkI2bgYBcb15-hETZR+QSFhNPQM0bHxkVe7CDf9zUewVC4TeHziTHYNXMligAHo4VAAIyLKCAEjlAFRygE-tQCGMYAQt2GCjxgDc9QBjabCEBA4GRAiRtCA5vIGfZCSBAhIWiUbgAfKCs9ktX7nFywpm3fjNfkc648DCwsxigGUKWCtrnWEIqAAJlRgCDNQA55qzABTqmNxgFo5QC-CYANbSNgBh-wDFCYAJOSxgBS9PEAN3cEEAECrE+UZLI5L0FGXoDA2Jw7NWyiMgRyQrhcTUAZj1hoURsAAHLYnFmm22wBnytnzYBYOXzTsAa8o2j1e2E9LkxpnrROuRV3AYq1bqxOmVXSc6x5sbKAld3STwHVLQNAoACqCG0WAAyjRxfcqK9GDVjCuZEqoCJRKDGIoTKoSFIZOdFAAyc+XqB+aiGWYnM6ygoz1CynCypjRL950XJ9gCYBNvG4ZBvzDZcaESZIJCGfxgFoWkoDARA5wXWC93bZpj2YAAKXQF1cXcAEpXEA7Dd3g9hEJIZDUJIdDMIgIDiIXExXAIyjHwCYEXgid4YghGEuFoDlCIAQhI7RyKgSlgBIljREUA4uCCEhqCoKkEH8Co2EGBdFiQMBtFoYBCIAchMazyKsJF9mMSSoBklBEAMhSlJU8x1OSTTaR0jz9IqABBBAZFYXTPIqUzzMsmyb3spJAu04BFPyXRtGAXwBOeAjwXiIy1NSqAJGCNztAgDLaCMgAGBI7CgLAYtCiKEEWarGEqJraAAan6hSLB7LSdKsVlok9PJHCMkKDI6qxaEceKLKs6zWBSgLE01A1ACHlQAHU0AJ91AHm-fNABQ5EtAHozA7ABG-W1AEwlQAbeMAI2NAC45O7YVcwjKSQbLgAmpxhthCSpI6uAQEWWgkHBkAfqynLAbjcjgZ7Htfv+pGVrAXQkAqQjpv0ciyp7LwIG0FBxLRrgMcR1lZuiqxaYB+mpq9ZzqcUWEyYp6ARrR5msaMwmIBJqAua4CXMuUhAWOZpIufYMaMt+oyMKgjjrIqYBgDAZwEW0QJ-B0CpAmoZxk3qq24RMEhMAgVgACs4H8YYbzgbJWCRAAOG87YwB2EDNiA-ft1gg5QLV3c9rV6q29hNRdQAKV0zQBABkASujABX4wA9tUAHgVAEhzQAF40ALk9AG8fQBo9QTxEUSgQBNvxz3PmcALO1AEk5CugQKzcRM+f8oEADfirpLQB8TUAODNADsPW1AAPTQBVm0AODlDrkvEK8AbfjABkIwBnRUAFQCq+1VFAH95JPAG2bcvbSzvOl-L+eDsXleN+3sbAmqrrAgYeGkGJpWgsfiBn9f37Fg9hAYmQA)


## 其它

### 逆变、协变、双向协变与不变

> ts就是为了做类型检查的，不同的类型只能使用该类型的属性和方法，但是为了增加类型系统的灵活性，ts设计了父子类型的概念
> 
> 父子类型之间自然应该能赋值，也就是会发生型变（variant）。型变（类型改变）分两种：协变和逆变
>
> 非父子类型之间不能发生型变，也就是不变的特性


:::tip 怎么确定父子类型
通过结构，更具体的那个是子类型。这里的 Guang 有 Person 的所有属性，并且还多了一些属性，所以 Guang 是 Person 的子类型。
:::

#### 协变
> **子类型可以赋值给父类型**，简单但不是很准确来讲就是：更多的可以赋值给少的

[试一下](https://www.typescriptlang.org/play/?strictFunctionTypes=false&ts=4.5.0-beta#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyxyIcAthAFzIZhSgDmA3ESXI9aQK7kBG0VgF9kBAqEixEKAOLc4IRvjbEylGnQaLWJZBy4heAqDpIALLHz7AIGDfSYBtALoEhYgDYQwyAA6YcGnQobFwAXmVdNS4AchiAGhU9ThoAJgAGN1YvH0Z5RRo5BSUIwiiKWLzihKT9NPTE3QsrGztkRxjfDzgAT2RGCoTkGIB3BjAmGNchVgJ-EJxkCKrtAiA)




#### 逆变
> 函数赋值的时候**函数参数**的性质，参数的**父类型可以赋值给子类型**，更少的赋值给更多的，作为参数也是没有问题
> 
> 双向协变是不开启 strictFunctionTypes 的话，函数参数子类型也可以赋值给父类型， ts 2.x之后默认开启 strictFunctionTypes


[试一下](https://www.typescriptlang.org/play/?ts=4.5.0-beta#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyxyIcAthAFzIZhSgDmA3ESXI9aQK7kBG0VgF9kBAqEixEKAOLc4IRvjbEylGnQaLWJZBy4heAqDpIALLHz7AIGDfSYBtALoEhYgDYQwyAA5awAAlLa1saAApGeUUaOQVGAEpkAF4APmQANyxgABNWAn8JYKsbDBTkSOjElPTCXQQcbC8AOg8sRkr45osS2wThT28-AIA5Ci5w30wcGnQobBAktMzsvLFC8DHKcsnpxZrlesasFraOqfmcZrUIfrd1gOLQsuThiS2IfI2wD-Lvp9K+SAA)


### 内置的高级类型

1. Parameters 用于提取函数类型的参数类型
2. ConstructorParameters 用于提取构造器参数的类型。
3. InstanceType 提取构造器返回值的类型
4. ThisParameterType 提取 this 对象
5. OmitThisParameter 方法类型中移除 this 参数
6. ReturnType 用于提取函数类型的返回值类型。
7. Record 创建对象
8. Readonly 只读
9. Partial 可选
10. Required 必选
11. Pick 提取属性子集
12. Omit 排除属性子集
14. Extract 提取类型子集
13. Exclude 排除类型子集
14. Awaited 解析和提取 Promise 类型的结果类型
15. NonNullable 用于判断是否为非空类型，也就是不是 null 或者 undefined 的类型的
16. Uppercase、Lowercase、Capitalize、Uncapitalize 分别实现大写、小写、首字母大写、去掉首字母大写的

