---
tags: 
  - 其它
description: 其它
slug: /8c5445c
---

## 一、说说你对event loop的理解

### JS是门单线程、非阻塞语言
- 单线程：js是基于浏览器的，多线程操作dom可能引起混乱
- 非阻塞：基于event loop机制
  

### Event loop：
- 将同步任务依次放入执行栈；
- 进行异步任务时，将异步任务的回调加入事件队列, 并不立刻执行，而是继续执行执行栈中的其他任务；
- 等执行栈中的所有任务都执行完毕，再从事件队列中取出异步任务
- 异步任务又分为微任务 和 宏任务，按事件队列，优先取出微任务，将当前任务的回调任务放到执行栈
- 等执行栈中的所有任务都执行完毕，再从事件队列中取出异步任务，以此类推，形成一个循环，只到执行栈中所有任务都执行完毕


:::tip

微任务：`Promise`、`MutationObserver`、`postMessage`、`node`的`process.nextTick`

宏任务：`settimeout`、`setInterval`、`requestAnimationFrame`、`I/O`操作

:::


## 二、柯里化
- 理解：通过闭包将参数保存起来，等到参数数量达到函数的形参时，开始执行函数
- 实现

```
var curry = fn => {
  var judge = (...args) => {
    if ((args.length === fn.length) {
      return fn(...args);
    }
    return (...arg) => judge(...args, ...arg);
  }
}
```



## 三、说说 JavaScript 中内存泄漏的几种情况？
- 内存泄漏：由于疏忽或错误造成程序未能释放已经不再使用的内存
- js带自动垃圾回收机制，会定期找出不在继续使用的变量，释放内存
- 常见的内存泄漏：
  - 没用的全局变量
  - 未移除的定时器
  - 一些不合理的闭包
  - 移除DOM元素，但未移除对元素的引用 

## 四、什么是事件代理？有哪些应用场景？
- 把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素
- 当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数
- 比如，事件绑定在ul上，而目标元素是li，点击li元素时，通过事件冒泡，触发ul的事件回调，再通过event.target来判断响应的目标元素
- 好处：减少绑定更多元素事件，提升性能