# Rust 是什么？

Rust 是一种系统编程语言，目标是：
 • 安全（特别是内存安全）
 • 并发（多线程编程）
 • 性能高（接近 C/C++ 的速度）
 • 现代化开发体验（好用的包管理、强类型系统、清晰的编译报错）

⸻

## Rust、C/C++、JS对比

### 1.设计目标

| 特性     | Rust                             | C                       | JavaScript                     |
| -------- | -------------------------------- | ----------------------- | ------------------------------ |
| 类型系统 | 静态强类型(编译时检查)           | 静态弱类型(容易出错)    | 动态类型(运行时决定类型)       |
| 安全性   | 高:内存安全、并发安全            | 低:容易内存泄漏、野指针 | 高(在运行层面，不接触底层内存) |
| 性能     | 接近C的性能                      | 极致性能                | 解释执行，性能不如C/Rust       |
| 编程范式 | 多范式(函数式+面向对象+数据驱动) | 过程式编程              | 基于对象+函数式                |

### 2.运行环境

| 比较点         | Rust                      | C                      | JavaScript                 |
| -------------- | ------------------------- | ---------------------- | -------------------------- |
| 运行平台       | 编译成本地机器码          | 编译成本地机器码       | 浏览器/Node.js解释执行     |
| 是否跨平台     | 是(但需为每个平台编译)    | 是(但需为每个平台编译) | 是(只要浏览器能跑JS就能用) |
| 是否需安装环境 | 需要 Rust 编译器(如cargo) | 需要编译器(如gcc)      | 浏览器即可运行             |

### 3.内存管理方式

| 特性     | Rust                        | C                          | JavaScript               |
| -------- | --------------------------- | -------------------------- | ------------------------ |
| 内存分配 | 手动+所有权系统(编译器检查) | 手动分配和释放(容易出错)   | 自动垃圾回收(GC)         |
| 内存安全 | 编译时保障                  | 容易有悬垂指针、缓冲区溢出 | 不涉及底层指针，比较安全 |

### 4.使用场景

| 场景                     | Rust                    | C                             | JavaScript                 |
| ------------------------ | ----------------------- | ----------------------------- | -------------------------- |
| 系统/内核开发            | **✓** 非常适合          | **✓** 最传统的选择            | **✗** 不支持               |
| 嵌入式/loT               | **✓** 很适合            | **✓** 非常适合                | **✗** 不支持               |
| Web 前端开发             | **✓** (通过WebAssembly) | **✗** 不支持                  | **✓** 主战场               |
| Web 后端 (如Actix、Axum) | **✓** (如Actix、Axum)   | **✗** 原始实现太过复杂        | **✓** (Node.js、Deno)      |
| 游戏开发 (Bevy等)        | **✓** (Bevy等)          | **✓** (Unity底层、自己写引擎) | **✓** (Web游戏)            |
| 命令行工具               | **✓** 高效+跨平台       | **✓** 性能高                  | **✗** 不适合               |
| 快速原型/小工具          | **✗**  编译慢/语法严谨  | **✗** 开发效率低              | **✓** 快速上手，开发效率高 |

### 5.示例代码对比

```rust
fn add(x: i32, y: i32) -> i32 {
    x + y
}
fn main() {
    let x = 5;
    let y = 10;
    let sum = add(x, y);
    println!("The sum is: {}", sum);
}
main();
```

```c
#include <stdio.h>
int add(int x, int y) {
    return x + y;
}
int main() {
    int x = 5;
    int y = 10;
    int sum = add(x, y);
    printf("The sum is: %d\n", sum);
    return 0;
}
main();
```

```javascript
function add(x, y) {
    return x + y;
}
function main() {
    let x = 5;
    let y = 10;
    let sum = add(x, y);
    console.log(`The sum is: ${sum}`);
}
main();
```

### 6.总结

`Rust`: 性能像 C，安全像 Java，开发体验像现代脚本语言。
`C`: 性能高，安全低，开发体验一般。
`JavaScript`: 性能一般，安全高，开发体验好。适用于各种 Web 和快速开发场景。

## 语法

### 1.常量

```rust
// 声明常量
const PI: f64 = 3.14159;
const MAX: i32 = 100;
```

### 2.变量

```rust
// 声明变量
let x = 5; // 类型推断
let mut y = 10; // 可变变量
```

:::tip 常量与不可变变量的区别

| 特性            | 不可变变量 let x=5;      | 常量 const X:i32 = 5;        |
| --------------- | ------------------------ | ---------------------------- |
| 是否可变        | 不可变                   | 不可变（也永远不能变）       |
| 是否需要 mut    | 可以加 mut 成为可变      | 永远不可变X                  |
| 是否需显式类型  | 不需要                   | 必须指定类型                 |
| 定义的位置限制  | 只能在函数体或局部作用域 | 可定义在任何作用域(全局)     |
| 生命周期/作用域 | 运行时变量，作用域受限   | 编译期常量，编译后常驻       |
| 内存分配        | 运行时栈上               | 编译时嵌入代码中(无运行开销) |
| 命名习惯        | 小写开头 let x=5         | 全大写 const x:i32 =5        |

:::

### 3.函数

```rust
// 函数定义
fn add(x: i32, y: i32) -> i32 {
    x + y
}
// 调用函数
let sum = add(5, 10);
```

### 4.控制流

```rust
// if 语句
let number = 10;
if number > 5 {
    println!("Number is greater than 5");
}
// 循环
let mut i = 0;
while i < 5 {
    println!("i is: {}", i);
    i += 1;
}
// for 循环
for i in 0..5 {
    println!("i is: {}", i);
}
// 循环标签
'outer: for i in 0..3 {
    for j in 0..3 {
        if j == 1 {
            continue 'outer;
        }
        println!("i: {}, j: {}", i, j);
    }
}
```
